package tcg.credential;

import java.util.Arrays;
import java.util.List;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Singular;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Integer;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;
import org.bouncycastle.asn1.DERTaggedObject;
import org.bouncycastle.asn1.x509.AlgorithmIdentifier;
import org.bouncycastle.asn1.x509.AttCertIssuer;
import org.bouncycastle.asn1.x509.AttCertValidityPeriod;
import org.bouncycastle.asn1.x509.Attribute;
import org.bouncycastle.asn1.x509.Extension;
import org.bouncycastle.asn1.x509.Holder;

/**
 * <pre>
 *    AttrCertTemplate ::= SEQUENCE {
 *        version                 [0] AttrCertVersion OPTIONAL, -- version must be v2
 *        holder                  [1] AttrCertHolder OPTIONAL,
 *        issuer                  [2] AttrCertIssuer OPTIONAL,
 *        signature               [3] SignatureAlgorithmIdentifier OPTIONAL,
 *        attrCertValidityPeriod  [4] AttrCertValidtyPeriod OPTIONAL,
 *        attributes              [5] Attributes OPTIONAL,
 *        extensions              [6] Extensions OPTIONAL }
 * </pre>
 */
@AllArgsConstructor
@Builder(toBuilder = true)
@Getter
@NoArgsConstructor(force = true)
public class AttrCertTemplate extends ASN1Object {
    private static final int MIN_SEQUENCE_SIZE = 0;
    private static final int MAX_SEQUENCE_SIZE = 7;

    private ASN1Integer version;
    private Holder holder;
    private AttCertIssuer issuer;
    private AlgorithmIdentifier signatureAlgorithm;
    private AttCertValidityPeriod validity;
    @Singular
    private List<Attribute> attributes;
    @Singular
    private List<Extension> extensions;

    public static AttrCertTemplate getInstance(Object obj) {
        if (obj == null || obj instanceof AttrCertTemplate) {
            return (AttrCertTemplate) obj;
        }
        if (obj instanceof ASN1Sequence seq) {
            return AttrCertTemplate.fromASN1Sequence(seq);
        }
        throw new IllegalArgumentException("Illegal argument in getInstance: " + obj.getClass().getName());
    }
    
    public static AttrCertTemplate fromASN1Sequence(@NonNull ASN1Sequence seq) {
        if (seq.size() < AttrCertTemplate.MIN_SEQUENCE_SIZE) {
            throw new IllegalArgumentException("Bad sequence size: " + seq.size());
        }

        AttrCertTemplate.AttrCertTemplateBuilder builder = AttrCertTemplate.builder();

        ASN1Utils.parseTaggedElements(seq).forEach((key, value) -> {
            switch (key) {
                case 0 -> builder.version(ASN1Integer.getInstance(value));
                case 1 -> builder.holder(Holder.getInstance(value));
                case 2 -> builder.issuer(AttCertIssuer.getInstance(value));
                case 3 -> builder.signatureAlgorithm(AlgorithmIdentifier.getInstance(value));
                case 4 -> builder.validity(AttCertValidityPeriod.getInstance(value));
                case 5 -> builder.attributesFromSequence(ASN1Sequence.getInstance(value));
                case 6 -> builder.extensionsFromSequence(ASN1Sequence.getInstance(value));
                default -> {}
            }
        });

        return builder.build();
    }

    /**
     * @return This object as an ASN1Sequence
     */
    public ASN1Primitive toASN1Primitive() {
        ASN1EncodableVector vec = new ASN1EncodableVector();
        if (version != null) {
            vec.add(new DERTaggedObject(false, 0, version));
        }
        if (holder != null) {
            vec.add(new DERTaggedObject(false, 1, holder));
        }
        if (issuer != null) {
            vec.add(new DERTaggedObject(false, 2, issuer));
        }
        if (signatureAlgorithm != null) {
            vec.add(new DERTaggedObject(false, 3, signatureAlgorithm));
        }
        if (validity != null) {
            vec.add(new DERTaggedObject(false, 4, validity));
        }
        if (attributes != null) {
            vec.add(new DERTaggedObject(false, 5, new DERSequence(ASN1Utils.toASN1EncodableVector(attributes))));
        }
        if (extensions != null) {
            vec.add(new DERTaggedObject(false, 6, new DERSequence(ASN1Utils.toASN1EncodableVector(extensions))));
        }
        return new DERSequence(vec);
    }

	/**
	 * The rest of this builder is generated by lombok Builder annotation
	 */
	public static class AttrCertTemplateBuilder {
		/**
		 * Reads elements of the given sequence as Attribute and adds them to the builder.
		 * @param seq ASN1Sequence
		 */
		public final void attributesFromSequence(@NonNull ASN1Sequence seq) {
			Arrays.asList(seq.toArray()).forEach(
					element ->
							this.attribute(Attribute.getInstance(element)));
		}

		/**
		 * Reads elements of the given sequence as Extension and adds them to the builder.
		 * @param seq ASN1Sequence
		 */
		public final void extensionsFromSequence(@NonNull ASN1Sequence seq) {
			Arrays.asList(seq.toArray()).forEach(
					element ->
							this.extension(Extension.getInstance(element)));
		}
	}
}
