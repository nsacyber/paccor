package tcg.credential;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import org.bouncycastle.asn1.ASN1EncodableVector;
import org.bouncycastle.asn1.ASN1Object;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.ASN1Sequence;
import org.bouncycastle.asn1.DERSequence;

/**
 * <pre>
 * &lt;?&gt; ::= SEQUENCE(SIZE(1..MAX)) OF Trait
 * </pre>
 */
@AllArgsConstructor
@Builder(toBuilder = true)
@Getter
@NoArgsConstructor(force = true)
public class TraitSequence extends ASN1Object {
    public static final int MIN_SEQUENCE_SIZE = 0;

    private final Map<Class<? extends Trait<?, ?>>, List<Trait<?, ?>>> traits;

    /**
     * Attempts to cast the provided object to TraitSequence.
     * If the object is an ASN1Sequence, the object is parsed by fromASN1Sequence.
     * @param obj the object to parse
     * @return TraitSequence
     */
    public static TraitSequence getInstance(Object obj) {
        if (obj == null || obj instanceof TraitSequence) {
            return (TraitSequence) obj;
        }
        if (obj instanceof ASN1Sequence seq) {
            return TraitSequence.fromASN1Sequence(seq);
        }
        throw new IllegalArgumentException("Illegal argument in getInstance: " + obj.getClass().getName());
    }

    /**
     * Attempts to parse the given ASN1Sequence.
     * @param seq An ASN1Sequence
     * @return TraitSequence
     */
    public static TraitSequence fromASN1Sequence(@NonNull ASN1Sequence seq) {
        if (seq.size() < TraitSequence.MIN_SEQUENCE_SIZE) {
            throw new IllegalArgumentException("Bad sequence size: " + seq.size());
        }

        TraitSequenceBuilder builder = TraitSequence.builder();
        builder.traitsFromSequence(seq);
        return builder.build();
    }

    /**
     * @return This object as an ASN1Sequence
     */
    public ASN1Primitive toASN1Primitive() {
        ASN1EncodableVector vec = new ASN1EncodableVector();
        if (traits != null) {
            vec.add(new DERSequence(ASN1Utils.toASN1EncodableVector(
                    traits.values().stream()
                            .filter(Objects::nonNull)
                            .flatMap(Collection::stream)
                            .toList())));
        }
        return new DERSequence(vec);
    }

    /**
     * The rest of this builder is generated by lombok Builder annotation
     */
    public static class TraitSequenceBuilder {
        public TraitSequenceBuilder trait(Trait<?, ?> traitValue) {
            if (traits == null) {
                traits = new java.util.HashMap<>();
            }

            if (!traits.containsKey(traitValue.getTraitType())) {
                traits.put(traitValue.getTraitType(), new ArrayList<>());
            }
            List<Trait<?, ?>> list = traits.get(traitValue.getTraitType());
            list.add(traitValue);
            traits.put(traitValue.getTraitType(), list);
            return this;
        }

        /**
         * Attempts to recover Traits from the ASN1Sequence and then read their TraitID and process them into appropriate types.
         * @param seq ASN1Sequence
         */
        public final void traitsFromSequence(@NonNull ASN1Sequence seq) {
            Arrays.stream(seq.toArray())
                    .map(obj -> (ASN1Object)obj)
                    .forEach(
                    trait -> {
                            ASN1ObjectTrait basic = ASN1ObjectTrait.getInstance(trait);
                            this.trait(Trait.getInstance(trait.toASN1Primitive(), TraitId.getTraitClassForId(basic.getTraitId())));
                    });
        }
    }
}
