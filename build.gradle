wrapper {
    gradleVersion = '4.5.1'
}
import org.gradle.util.VersionNumber

allprojects {
    repositories {
        mavenCentral();
    }

    tasks.withType(Test) {
        useTestNG() {
        }
        afterSuite { desc, result ->
            if (desc.parent == null) {
                logger.lifecycle("${result.successfulTestCount}/${result.testCount} tests passed")
            }
        }
    }

    // Version definitions of all of the libraries we're using.  They're defined
    // here to ensure that all projects are using the same versions of common
    // dependencies:
    ext.libs = [
      bouncycastle:  ['org.bouncycastle:bcpkix-jdk15on:1.55', // Bouncy Castle license
                      'org.bouncycastle:bcprov-ext-jdk15on:1.55'],
      jackson:       ['com.fasterxml.jackson.core:jackson-core:2.9.4', // Apache 2.0
                      'com.fasterxml.jackson.core:jackson-annotations:2.9.4',
                      'com.fasterxml.jackson.core:jackson-databind:2.9.4'],
      jcommander:    'com.beust:jcommander:1.72', // cli and required by testng, Apache 2.0
      powermock:     ['org.powermock:powermock-module-testng:1.6.5', // Apache 2.0
                      'org.powermock:powermock-api-mockito:1.6.5'],
      testng:        'org.testng:testng:6.13.1', // Apache 2.0
    ]
}

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        // The ospackage plugin has breaking differences based on gradle version
        // paccor must support gradle 4.5.1 for the forseeable future
        String ospackage_version = "4.9.3" // verified to work with gradle 4.5.1
        if ((VersionNumber.parse(gradle.gradleVersion) >= VersionNumber.parse('5.1'))) {
            ospackage_version = "8.4.1"
            project.logger.lifecycle("Selecting ospackage $ospackage_version for your gradle version $gradle.gradleVersion.")
            project.logger.lifecycle("Customize the ospackage_version variable in build.gradle if met with plugin errors.")
        }
        classpath "com.netflix.nebula:gradle-ospackage-plugin:$ospackage_version"
    }
}

apply plugin: 'eclipse'
apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'nebula.ospackage'

ext.refsDir = new File(projectDir, 'refs')

sourceCompatibility = 1.8

dependencies {
    implementation libs.bouncycastle
    implementation libs.jackson
    implementation libs.jcommander

    testImplementation libs.testng
    testImplementation libs.powermock
}

// Application packaging into a zip file
def createScript(project, mainClass, name) {
  project.tasks.create(name: name, type: CreateStartScripts) {
    outputDir       = new File(project.buildDir, 'scripts')
    mainClassName   = mainClass
    applicationName = name
    classpath       = project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files + project.configurations.runtimeClasspath
  }
  project.tasks[name].dependsOn(project.jar)

  project.applicationDistribution.with {
    into("bin") {
      from(project.tasks[name])
      fileMode = 0755
      duplicatesStrategy = 'exclude' // IMPORTANT: eliminates duplicate files within the ZIP
    }
  }
}

// Suppress standard application plugin behavior in favor of easier to read program declarations below
startScripts.enabled = false
run.enabled = false

createScript(project, 'cli.DeviceObserverCli', 'observer')
createScript(project, 'cli.SigningCli', 'signer')
createScript(project, 'cli.ValidatorCli', 'validator')

// Include files into a ZIP
applicationDistribution.from("scripts/") {
    into "scripts"
}
applicationDistribution.from("docs/") {
    into "docs"
}
applicationDistribution.from("./") {
    include {
        FileTreeElement details ->
        details.file.name.endsWith('.md')
    }
    into "./"
}

// Produce packages
ospackage {
    packageName='paccor'
    os=LINUX
    version='1.1.4'
    release='8'

    into '/opt/paccor'
    user 'root'
    fileMode=0755

    requires('dmidecode', '3.2', GREATER | EQUAL)
    requires('ethtool')
    requires('jq')
    requires('lshw')
    requires('nvme-cli')
    requires('vim-common')

    from(jar.outputs.files) {
        into 'lib'
    }

    from('lib') {
        into 'lib'
    }

    from(configurations.runtimeClasspath) {
        into 'lib'
    }

    from('build/scripts') {
        exclude {
            FileTreeElement details ->
            details.file.name.endsWith('.bat')
        }
        into 'bin'
    }
  
    from('scripts') {
        into 'scripts'
    }

    from('docs') {
        exclude {
            FileTreeElement details ->
            details.file.name.endsWith('.odt')
        }
        into 'docs'
    }

    from('./') {
        include {
            FileTreeElement details ->
            details.file.name.endsWith('.md')
        }
        into './'
    }
}

