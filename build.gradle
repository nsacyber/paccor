plugins {
    id 'application'
    id 'com.netflix.nebula.ospackage' version '11.11.2'
    id 'java'
    id 'maven-publish'
    id 'signing'
}

// version number
def base_version = '1.5.0'
def base_release = 'beta1'
def archive_version = "${base_version}-${base_release}"

version = "${base_version}${base_release}"

java {
    withJavadocJar()
    withSourcesJar()
}

allprojects {
    repositories {
        mavenCentral();
    }

    // Version definitions of all of the libraries we're using.  They're defined
    // here to ensure that all projects are using the same versions of common
    // dependencies:
    ext.libs = [
      bouncycastle:  ['org.bouncycastle:bcpkix-jdk18on:1.80', // Bouncy Castle license
                      'org.bouncycastle:bcprov-jdk18on:1.80'],
      jackson:       ['com.fasterxml.jackson.core:jackson-core:2.18.3', // Apache 2.0
                      'com.fasterxml.jackson.core:jackson-annotations:2.18.3',
                      'com.fasterxml.jackson.core:jackson-databind:2.18.3'],
      jcommander:     'org.jcommander:jcommander:2.0', // Apache 2.0
      junit:          'org.junit.jupiter:junit-jupiter:5.12.2', // EPL 2.0
      mockito:       'org.mockito:mockito-junit-jupiter:5.17.0' // MIT
    ]
}

dependencies {
    implementation libs.bouncycastle
    implementation libs.jackson
    implementation libs.jcommander

    testImplementation libs.junit
    testImplementation libs.mockito
}

// Maven packaging and signing
publishing {
    publications {
        mavenJava(MavenPublication) {
            pom {
                from components.java

                description = 'The Platform Attribute Certificate Creator can gather component details, create, sign, and validate the TCG-defined Platform Credential. #nsacyber'
                group = 'io.github.nsacyber.paccor'
                name = 'paccor'
                packaging = 'jar'
                url = 'https://github.com/nsacyber/paccor'
                version = "${version}"

                licenses {
                    license {
                        name = 'The Apache Software License, Version 2.0'
                        url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                        distribution = 'repo'
                    }
                }

                developers {
                    developer {
                        id = 'iadgovuser29'
                        name = 'iadgovuser29'
                        email = '33426478+iadgovuser29@users.noreply.github.com'
                        organization = 'NSA Cybersecurity Directorate'
                        organizationUrl = 'https://github.com/nsacyber'
                    }
                }

                scm {
                  connection = 'scm:git:git://github.com:nsacyber/paccor.git'
                  developerConnection = 'scm:git:git://github.com:nsacyber/paccor.git'
                  url = 'https://github.com/nsacyber/paccor'
                }
            }
        }
    }
    repositories {
        maven {
            def domain = hasProperty('sonatypeDomain') ? sonatypeDomain : ""
            def user = hasProperty('ossrhUsername') ? ossrhUsername : ""
            def pass = hasProperty('ossrhPassword') ? ossrhPassword : ""
            def releasesRepoUrl = "https://${domain}/service/local/staging/deploy/maven2/"
            def snapshotsRepoUrl = "https://${domain}/content/repositories/snapshots/"
            url = version.endsWith('SNAPSHOT') ? snapshotsRepoUrl : releasesRepoUrl
            credentials {
                username = user
                password = pass
            }
        }
    }
}

signing {
    sign publishing.publications.mavenJava
}

// Application packaging into a zip file
def createScript(project, mainClass, name) {
  project.tasks.create(name: name, type: CreateStartScripts) {
    outputDir       = new File(project.buildDir, 'scripts')
    mainClassName   = mainClass
    applicationName = name
    classpath       = project.tasks[JavaPlugin.JAR_TASK_NAME].outputs.files + project.configurations.runtimeClasspath
  }
  project.tasks[name].dependsOn(project.jar)

  project.applicationDistribution.with {
    into("bin") {
      from(project.tasks[name])
      fileMode = 0755
      duplicatesStrategy = 'exclude' // IMPORTANT: eliminates duplicate files within the ZIP
    }
  }
    tasks.named("buildDeb") {
        dependsOn tasks.named(name)
    }
    tasks.named("buildRpm") {
        dependsOn tasks.named(name)
    }
}

// Suppress standard application plugin behavior in favor of easier to read program declarations below
startScripts.enabled = false
run.enabled = false

createScript(project, 'cli.DeviceObserverCli', 'observer')
createScript(project, 'cli.SigningCli', 'signer')
createScript(project, 'cli.ValidatorCli', 'validator')

// Include files into a ZIP
applicationDistribution.from("scripts/") {
    into "scripts"
}
applicationDistribution.from("docs/") {
    into "docs"
}
applicationDistribution.from("./") {
    include {
        FileTreeElement details ->
        details.file.name.endsWith('.md')
    }
    into "./"
}

def createCcrPathString(String ccr, String config, String runtime) {
    def prefix = "${project.rootDir}${File.separator}dotnet${File.separator}ComponentClassRegistry"
    def netVersion = "net8.0"
    return "${prefix}${File.separator}${ccr}${File.separator}bin${File.separator}${config}${File.separator}${netVersion}${File.separator}${runtime}${File.separator}publish${File.separator}${ccr}"
}

def getDotnetConfig() {
    return "Release"
}

def getDotnetRuntimeLinux() {
    return "linux-x64"
}

def getDotnetRuntimeWin() {
    return "win-x64"
}

def getZipOutputPath() {
    return layout.buildDirectory.dir("distributions")
}

def getStagingPathForUtilities() {
    return layout.buildDirectory.dir("tmp${File.separator}staging")
}

def createLinuxZipFileList() {
    def config = getDotnetConfig()
    def runtime = getDotnetRuntimeLinux()
    def smbios = file(createCcrPathString("SmbiosCli", config, runtime))
    def pcie = file(createCcrPathString("PcieCli", config, runtime))
    def storage = file(createCcrPathString("StorageCli", config, runtime))

    return [smbios, pcie, storage]
}

def createWinZipFileList() {
    def config = getDotnetConfig()
    def runtime = getDotnetRuntimeWin()
    def smbios = file(createCcrPathString("SmbiosCli", config, runtime) + ".exe")
    def pcie = file(createCcrPathString("PcieCli", config, runtime) + ".exe")
    def storage = file(createCcrPathString("StorageCli", config, runtime) + ".exe")

    return [smbios, pcie, storage]
}

def checkFilesExist(ArrayList<File> fileList, String destinationIfExists) {
    fileList.each { file ->
        if (file.exists()) {
            println "Copied ${file.name} into ${destinationIfExists}."
        }
    }
}

// Create Windows ZIP
tasks.register("distZipWin", Zip) {
    dependsOn tasks.named("distZip")

    def destinationInZip = tasks.distZip.archiveBaseName.get() + "${File.separator}scripts${File.separator}windows"
    def zipOutputDestination = getZipOutputPath()
    def runtime = getDotnetRuntimeWin()
    def archiveName = tasks.distZip.archiveBaseName.get() + ".${archive_version}.${runtime}.zip"

    def fileList = createWinZipFileList()

    from(zipTree(tasks.distZip.archiveFile.get().asFile))
    from(fileList.findAll { it.exists() }) {
        into "${destinationInZip}"
    }

    archiveFileName.set(archiveName)
    destinationDirectory.set(zipOutputDestination)

    doFirst {
        checkFilesExist(fileList, "${archiveName}")
    }
}

// Create Linux ZIP
tasks.register("distZipLinux", Zip) {
    dependsOn tasks.named("distZip")

    def destinationInZip = tasks.distZip.archiveBaseName.get() + "${File.separator}scripts"
    def zipOutputDestination = getZipOutputPath()
    def runtime = getDotnetRuntimeLinux()
    def archiveName = tasks.distZip.archiveBaseName.get() + ".${archive_version}.${runtime}.zip"

    def fileList = createLinuxZipFileList()

    from(zipTree(tasks.distZip.archiveFile.get().asFile))
    from(fileList.findAll { it.exists() }) {
        into "${destinationInZip}"
    }

    archiveFileName.set(archiveName)
    destinationDirectory.set(zipOutputDestination)

    doFirst {
        checkFilesExist(fileList, "${archiveName}")
    }
}

// Copies linux registry utilities into a packaging staging folder, if they exist
tasks.register("stageUtilsForDebRpm", Copy) {
    def stagingFolder = file(getStagingPathForUtilities())
    def fileList = createLinuxZipFileList()

    from fileList.findAll { it.exists() }
    into "${stagingFolder}"

    doFirst {
        checkFilesExist(fileList, "${stagingFolder}")
    }
}

tasks.named("buildDeb") {
    dependsOn tasks.named("stageUtilsForDebRpm")
}

tasks.named("buildRpm") {
    dependsOn tasks.named("stageUtilsForDebRpm")
}

// Produce packages
ospackage {
    packageName='paccor'
    os=LINUX
    version="${base_version}"
    release="${base_release}"

    into '/opt/paccor'
    user 'root'
    fileMode=0755

    requires('dmidecode', '3.2', GREATER | EQUAL)
    requires('ethtool')
    requires('java-17-openjdk-devel')
    requires('jq')
    requires('lshw')
    requires('nvme-cli')
    requires('vim-common')

    from(jar.outputs.files) {
        into 'lib'
    }

    from('lib') {
        into 'lib'
    }

    from(configurations.runtimeClasspath) {
        into 'lib'
    }

    from('build/scripts') {
        exclude {
            FileTreeElement details ->
            details.file.name.endsWith('.bat')
        }
        into 'bin'
    }
  
    from('scripts') {
        into 'scripts'
    }

    from('docs') {
        exclude {
            FileTreeElement details ->
            details.file.name.endsWith('.odt')
        }
        into 'docs'
    }

    from('./') {
        include {
            FileTreeElement details ->
            details.file.name.endsWith('.md')
        }
        into './'
    }

    from (getStagingPathForUtilities()) {
        into 'scripts'
    }
}

